#+title: Try it, use it, build it, patch it, cache it, pin it, dockerize it
#+author: Johannes Maier
#+REVEAL_PLUGINS: (notes)
#+REVEAL_THEME: ./css/themes/active.css
#+REVEAL_HLEVEL: 100
#+REVEAL_TRANS: none
#+OPTIONS: toc:nil num:nil reveal_center:nil H:4

* Ziel

- Teaser f√ºr Nix

FIXME Notes: keine Zeit f√ºr "was macht Nix, wie macht Nix was?", aber:
welche (Docker-)Probleme l√∂st es, wann sollte/kann man es einsetzen?

* Ausgangssituation

Unsere Anwendung / Services

#+begin_src plantuml :file plantuml/output/c4.png
@startuml
!include plantuml/plugins/C4_Container.puml

LAYOUT_LEFT_RIGHT()

Container(goBackend, "Calculator service (Go)")
Container(haskellBackend, "Caching service (Haskell)")
Container(client, "Client (Python)")
Rel(client, goBackend, "requests calculation of a * b")
Rel(goBackend, haskellBackend, "asks cache for existing result")
Rel(goBackend, haskellBackend, "adds new results")

@enduml
#+end_src

* Ausgangssituation

Unsere Anwendung / Services

#+begin_src plantuml :file plantuml/output/c4.png
@startuml
!include plantuml/plugins/C4_Container.puml

LAYOUT_LEFT_RIGHT()

Container(goBackend, "Calculator service (Go)")
Container(haskellBackend, "Caching service (Haskell)")
Container(client, "Client (Python)")
Rel(client, goBackend, "requests calculation of a * b")
Rel(goBackend, haskellBackend, "asks cache for existing result")
Rel(goBackend, haskellBackend, "adds new results")

@enduml
#+end_src

‚ûú Annahme: Soll als Docker-Komposition aus drei Images ausgeliefert
  werden

FIXME Notes: =./scripts/run...= zeigen

* Anforderungen an Auslieferung

1. Minimalit√§t bzgl.
   - Gr√∂√üe
   - installierter Software
2. Reproduzierbarkeit
3. Effizientes Bauen (Caching)
4. Evtl. festes Basisimage ("nur Debian erlaubt")

* Dockerfile des Caching-Service

#+begin_src dockerfile
FROM ubuntu

COPY . .
RUN apt-get update
RUN apt-get install -y cabal-install zlib1g-dev
RUN cabal update
RUN cabal build
CMD cabal run
#+end_src

Probleme?

* Dockerfile des Caching-Service

#+begin_src dockerfile
# Basisimage nicht gepinnt -> Reproduzierbarkeit
FROM ubuntu

# Zu fr√ºh -> zerst√∂rt Caching
COPY . .
# - Wird einzeln gecacht, daher bei √Ñnderungen danach nicht neu ausgef√ºhrt
# - Reproduzierbarkeit unm√∂glich
RUN apt-get update
RUN apt-get install -y cabal-install zlib1g-dev

# S.o.
RUN cabal update
RUN cabal build
# Hier sollte das gebaute Binary laufen und cabal unn√∂tig sein
CMD cabal run
#+end_src

- Keine Minimalit√§t wegen unn√∂tig enthaltener Software

* Zweiter Versuch

#+begin_src dockerfile
FROM haskell@sha256:f99b7e5417f75089b53e1077a68c6333c48b82aff478a8af292a7b7f8e541832

WORKDIR /build

COPY haskell-backend.cabal ./
COPY src-exe src-exe
RUN cabal update && cabal install

# Multi-stage build
FROM ubuntu@sha256:26c68657ccce2cb0a31b330cb0be2b5e108d467f641c62e13ab40cbec258c68d

RUN apt-get update && apt-get install -y zlib1g-dev

# Benutzer und Gruppe anlegen
RUN useradd -rm -d /home/ubuntu -s /bin/bash -g root -G sudo -u 1001 prod
USER prod

COPY --from=0 /root/.cabal/bin/haskell-backend ./
CMD [ "./haskell-backend" ]
#+end_src

Wie ist es nun?

* Zweiter Versuch: Analyse

#+begin_src dockerfile
FROM haskell@sha256:f99b7e5417f75089b53e1077a68c6333c48b82aff478a8af292a7b7f8e541832
...
#+end_src

- Feste Version der ben√∂tigten Tools ‚ûú besser

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
COPY haskell-backend.cabal ./
COPY src-exe src-exe
...
#+end_src

- Nur das N√∂tigste (vermutlich!) ‚ûú besser

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
RUN cabal update && cabal install
...
#+end_src

- Verlassen uns auf Abh√§ngigkeitsmanagement bzw. Pinning durch =cabal=

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
FROM ubuntu@sha256:26c68657ccce2cb0a31b330cb0be2b5e108d467f641c62e13ab40cbec258c68d
...
#+end_src

- Feste Basis ‚ûú besser
- Minimalit√§t?

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
RUN apt-get update && apt-get install -y zlib1g-dev
...
#+end_src

Ben√∂tigte Laufzeitabh√§ngigkeiten üòû

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
RUN useradd -rm -d /home/ubuntu -s /bin/bash -g root -G sudo -u 1001 prod
USER prod
...
#+end_src

- Service l√§uft unter dediziertem User, nicht =root= ‚ûú besser

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
COPY --from=0 /root/.cabal/bin/haskell-backend ./
CMD [ "./haskell-backend" ]
...
#+end_src

- Lediglich fertiges Binary enthalten aus vorigem Build

* Zweiter Versuch: Fazit

- Probleme beim Erstellen des =Dockerfile=: Laufzeitabh√§ngigkeiten
  fehlen oder unpassend!
- =alpine= nicht einfach m√∂glich (=musl= vs. =libc=, andere
  Bibliotheken/Versionen)
- Anzahl Pinning-Mechanismen = Anzahl Tools, Sprachen etc.

* Zweiter Versuch: Fazit

- Probleme beim Erstellen des =Dockerfile=: Laufzeitabh√§ngigkeiten
  fehlen oder unpassend! +*(Reproduzierbarkeit)*+
- =alpine= nicht einfach m√∂glich (=musl= vs. =libc=, andere
  Bibliotheken/Versionen) +*(Minimalit√§t)*+
- Anzahl Pinning-Mechanismen = Anzahl Tools, Sprachen
  etc. +*(Reproduzierbarkeit)*+

FIXME Notes: Tools hei√üt nicht unbedingt "Zur Entwicklung". Sobald
Docker verwendet wird, braucht man neue Tools. "Accelerate" -> freie
Toolwahl macht produktiver
- D√ºnnerer Pfad, Abweichen einfach, solange das Tooling es noch
  zul√§sst

* Zweiter Versuch: Fazit

‚ûú Gute Dockerfiles existieren, aber sie sind sehr schwer zu schreiben

‚ûú Je "besser" das Dockerfile, desto h√∂her der Wartungsaufwand

‚ûú Weicht i.d.R. von Entwicklungsumgebung ab (lokales Debugging?)

* Abh√§ngigkeitsmanagement

‚ûú Trennung "Compile-Time" vs. Runtime (Multi-Stage Build)

Was k√∂nnen wir tun?

* Wunsch

- Abh√§ngigkeitsgraph(en) unserer Programme bekannt und fixiert

FIXME Notes:
- Kriegen Reproduzierbarkeit in den Griff: sowohl lokal als auch in
  Docker
- Minimalit√§t: das minimale Docker-Image enth√§lt die Anwendung + alle
  Laufzeitabh√§ngigkeiten

* Laufzeitabh√§ngigkeiten des Caching-Service

#+begin_src console
$ ldd ~/path/to/haskell-backend
linux-vdso.so.1 (0x00007ffebdb24000)
libpthread.so.0 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/libpthread.so.0 (0x00007fb3b72db000)
libz.so.1 => /nix/store/b36ilvc5hhfpcp7kv1kvrkgcxxpmxfsd-zlib-1.2.12/lib/libz.so.1 (0x00007fb3b72bd000)
libgmp.so.10 => /nix/store/qxrvrhlfaislinykki6qy6nqd4wv8mdp-gmp-with-cxx-6.2.1/lib/libgmp.so.10 (0x00007fb3b721c000)
libc.so.6 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/libc.so.6 (0x00007fb3b701d000)
libm.so.6 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/libm.so.6 (0x00007fb3b6f42000)
librt.so.1 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/librt.so.1 (0x00007fb3b6f3d000)
libdl.so.2 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/libdl.so.2 (0x00007fb3b6f38000)
libffi.so.8 => /nix/store/gm6q7jmajjmnwd29wgbq2jm3x37vsw3h-libffi-3.4.2/lib/libffi.so.8 (0x00007fb3b6f2b000)
/nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/ld-linux-x86-64.so.2 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib64/ld-linux-x86-64.so.2 (0x00007fb3b72e2000)
#+end_src

FIXME Notes:
- feste Pfade, nicht =/lib=, =/usr/lib= etc.

* Nix!

https://nixos.org

- Package-Manager f√ºr "Bauanleitungen" (sprachagnostisch)
- Monorepo =nixos/nixpkgs=
- Programmiersprache
- (Betriebssystem: NixOS)

FIXME Notes:
- Packages werden von tausenden Contributors gepflegt

* Nix-Store

- =/nix/store=: read-only-FS
- Neue Version, neuer Hash, neuer Pfad
- Store ist Cache

FIXME Notes:
- habe Bauanleitungen f√ºr alles
- wenn ich wei√ü, was beteiligt ist, wei√ü ich, wenn sich √§ndert

* Bauanleitungsbeispiel

#+begin_src nix
{ pkgs }:

pkgs.stdenv.mkDerivation {
  pname = "my-example";
  version = "0.1.0";
  src = ./.;
  buildInputs = [ pkgs.gnumake pkgs.gcc ];
  buildPhase = "make";
  installPhase = ''
    make install
    cp -r myResult $out
  '';
}
#+end_src

FIXME Notes:
- lazy und funktional, obskur (lazy -> bauen nur das, was wir brauchen)
- Key-Value-Paare als Basiskonstrukt
- =src= kann alles M√∂gliche sein, idR Ordner oder Archive
- Bauvorgang √§hnlich zu Docker-Build: "sandboxed", pure
- =$out= Pfad in Store; Maschinerie hat Hash bereits erstellt (FIXME)

* In der Praxis

- =mkDerivation= low-level
- DSLs f√ºr viele Programmiersprachen, Shell-Skripte etc.

* Nixify it: Haskell-Service

#+begin_src nix
{ pkgs ? import <nixpkgs> { } }:

pkgs.haskellPackages.callCabal2nix "haskell-backend" ./. { }
#+end_src

FIXME Notes:
- =nix-build haskell_backend= zeigen
- =touch haskell_backend/blub && ...=
- Haskell-Pakete: idR eins pro Version gemirrort in =nixpkgs=

* Nixify it: Haskell-Service

Laufzeitabh√§ngigkeiten revisited:

#+begin_src shell
store_path=$(nix-build haskell_backend | tail -n 1)
echo $store_path

nix-store -qR $store_path

nix-store --export $(nix-store -qR $store_path) > closure
#+end_src

=closure= kann auf dem Zielsystem importiert werden.

FIXME Notes:
- Einfach mit Nix-Installation, oder wenn Nix das System
  "kontrolliert"
- Geht aber auch ohne Nix (nix-bundle, =nix bundle=)

* Nixify it: Go-Service

#+begin_src nix
{ pkgs ? import <nixpkgs> { } }:

pkgs.buildGoModule {
  src = pkgs.lib.cleanSource ./.;
  pname = "go_backend";
  version = "0.1.0";
  vendorSha256 = "sha256-pQpattmS9VmO3ZIQUFn66az8GSmB4IvYhTTCFn6SUmo=";
}
#+end_src

FIXME Notes:
- Go hat eingebauten Vendoring-Mechanismus mit Pinning/Hash

* Nixify it: Python-Client

#+begin_src nix
{ pkgs ? import <nixpkgs> { } }:

let myPython = pkgs.python310.withPackages (p: [ p.loguru p.requests ]);
in pkgs.writeShellScript "demo" ''
  ${myPython}/bin/python ${./python_client}/__init__.py
''
#+end_src

* Docker-Images mit Nix?

- Docker-Layers bestehen aus File-System-Diffs (OCI Image Format)
- Kennen Abschluss nixifizierter Anwendungen

‚ûú Kennen auch das Diff

‚ûú Nix kann Docker-Images erzeugen

FIXME Notes:
- Wenn ich das kenne, muss ich nicht mehrere Layer anlegen; alles auf
  einen Rutsch
- geht auch ohne Docker-Installation -> super, wenn CI das Artefakt
  erstellen soll/muss! (kein DinD, kein =docker build=, nur =nix=)

* Dockerize it: Haskell-Service

#+begin_src nix
{ pkgs ? import <nixpkgs> { } }:

let haskellBackend = import ../haskell_backend/default.nix { inherit pkgs; };
in pkgs.dockerTools.buildImage {
  name = "haskell-backend";
  tag = "latest";
  # contents = [ pkgs.bash pkgs.coreutils ];
  config = {
    # Start the Haskell service as the CMD of the image
    Cmd = "${haskellBackend}/bin/haskell-backend";
  };
}
#+end_src

FIXME Notes:
- Library =dockerTools=, Funktionen rund um Docker-Images
- =config= wie in OCI-Spezifikation, =docker inspect=
- Default: ein Layer, auch mit =contents=

* Benutzung

#+begin_src shell
nix-build nix/haskell-docker-image.nix
docker load < result
#+end_src

* Dockerize it: Go und Python

üòä

FIXME Notes: =./scripts/run_nix_setup_separate_services.sh=

* Ein Archiv f√ºr alles

#+begin_src shell
let
  haskellBackend = import ./haskell-docker-image.nix { inherit pkgs; };
  goBackend = import ./go-docker-image.nix { inherit pkgs; };
  pythonDemo = import ./python-client-docker-image.nix { inherit pkgs; };
in pkgs.dockerTools.mergeImages [ haskellBackend goBackend pythonDemo ]
#+end_src

* Neue "Anforderung"

Beide Services in einem Image!

* Dockerfile?

#+begin_src dockerfile
FROM haskell@sha256:f99b7e5417f75089b53e1077a68c6333c48b82aff478a8af292a7b7f8e541832

WORKDIR /build

COPY haskell-backend.cabal ./
COPY src-exe src-exe
RUN cabal update && cabal install

# Multi-stage build
FROM ubuntu@sha256:26c68657ccce2cb0a31b330cb0be2b5e108d467f641c62e13ab40cbec258c68d

RUN apt-get update && apt-get install -y zlib1g-dev

# Benutzer und Gruppe anlegen
RUN useradd -rm -d /home/ubuntu -s /bin/bash -g root -G sudo -u 1001 prod
USER prod

COPY --from=0 /root/.cabal/bin/haskell-backend ./
CMD [ "./haskell-backend" ]
#+end_src

FIXME Notes:
- Kopieren Binaries zusammen -> erh√∂hen Chance auf Probleme bei
  Laufzeitabh√§ngigkeiten
- Beides parallel starten? -> Skript
- Was, wenn beide Services gleiche Abh. in untersch. Versionen
  brauchen??

* Nix?

#+begin_src nix
let
  haskellBackend = import ../haskell_backend { inherit pkgs; };
  goBackend = import ../go_backend { inherit pkgs; };
  runScript = pkgs.writeShellScript "run" ''
    ${haskellBackend}/bin/haskell-backend &
    ${goBackend}/bin/server
  '';
in pkgs.dockerTools.buildImage {
  name = "both-backends";
  tag = "latest";
  config.Cmd = runScript;
}
#+end_src

FIXME Notes: Image-Gr√∂√üen vergleichen: go-backend, haskell-backend, both-backends
- Nicht mal Tools wie =ls= enthalten

* War's das?
* War's das?

- Minimal
- +Reproduzierbar+ Pinning fehlt!

* Nixpkgs pinnen

Naiv:

#+begin_src nix
let
  pkgs = import (builtins.fetchTarball {
    name = "my-nixpkgs-pin";
    url =
      "https://github.com/nixos/nixpkgs/archive/87d34a6b8982e901b8e50096b8e79ebc0e66cda0.tar.gz";
    sha256 = "sha256:0dqjw05vbdf6ahy71zag8gsbfcgrf7fxz3xkwqqwapl0qk9xk47a";
  }) { };
in ...
#+end_src

* Nixpkgs pinnen

- https://github.com/nmattia/niv
- https://nixos.wiki/wiki/Flakes

* Vorteile

- Reproduzierbar und programmierbar!
- Eine Sprache f√ºr alles
- Reproduzierbare (Entwicklungs-)Umgebungen (=nix-shell=) analog
- Riesige und hilfsbereite Community

FIXME Notes:
- Auf √Ñnderungen an Gegebenheiten schnell reagieren
- Einfachere CI ohne Docker/DinD
- Einheitlich: selbe Befehle in CI wie auch lokal
- Trotzdem mehrere Tools in Dev n√∂tig nat√ºrlich
- Sind alles Vorteile von Nix, nicht von "Docker mit Nix" ->
  Docker-Images sind Nebenprodukt

* Nix-H√ºrden

- Dokumentation
- Obskure Sprache (aber nicht schwer!)
- Lernkurve
- √ñkosystem bewegt sich sehr schnell
- Gro√üe Unterschiede bei Sprachunterst√ºtzung

FIXME Notes:
- abw√§gen, wann es sich lohnt, das einzusetzen
- Manche Sprachen/Build-Systeme funktionieren clashen mit Sandboxing
  -> impure

* Beispielrepo + Folien

- https://github.com/kenranunderscore/docker-mit-nix-talk

* FIXME Themen, die noch fehlen

- Caching
- Patching (eher nicht)

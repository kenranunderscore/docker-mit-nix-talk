#+title: Try it, use it, build it, patch it, cache it, pin it, dockerize it
#+author: Johannes Maier
#+REVEAL_PLUGINS: (notes)
#+REVEAL_THEME: ./css/themes/active.css
#+REVEAL_HLEVEL: 100
#+REVEAL_TRANS: none
#+OPTIONS: toc:nil reveal_center:nil H:4

* Ausgangssituation

Unsere Anwendung / Services

#+begin_src plantuml :file plantuml/output/c4.png
@startuml
!include plantuml/plugins/C4_Container.puml

LAYOUT_LEFT_RIGHT()

Container(goBackend, "Calculator service (Go)")
Container(haskellBackend, "Caching service (Haskell)")
Container(client, "Client (Python)")
Rel(client, goBackend, "requests calculation of a * b")
Rel(goBackend, haskellBackend, "asks cache for existing result")
Rel(goBackend, haskellBackend, "adds new results")

@enduml
#+end_src

* Ausgangssituation

Unsere Anwendung / Services

#+begin_src plantuml :file plantuml/output/c4.png
@startuml
!include plantuml/plugins/C4_Container.puml

LAYOUT_LEFT_RIGHT()

Container(goBackend, "Calculator service (Go)")
Container(haskellBackend, "Caching service (Haskell)")
Container(client, "Client (Python)")
Rel(client, goBackend, "requests calculation of a * b")
Rel(goBackend, haskellBackend, "asks cache for existing result")
Rel(goBackend, haskellBackend, "adds new results")

@enduml
#+end_src

‚ûú Soll als Docker-Komposition aus drei Images ausgeliefert werden

* Anforderungen an Auslieferung

1. Minimalit√§t bzgl.
   - Gr√∂√üe
   - installierter Software
2. Reproduzierbarkeit
3. Effizientes Bauen (Caching)
4. Evtl. festes Basisimage ("nur Debian erlaubt")

* Dockerfile des Caching-Service

#+begin_src dockerfile
FROM ubuntu

COPY . .
RUN apt-get update
RUN apt-get install -y cabal-install zlib1g-dev
RUN cabal update
RUN cabal build
CMD cabal run
#+end_src

Probleme?

* Dockerfile des Caching-Service

#+begin_src dockerfile
# Basisimage nicht gepinnt -> Reproduzierbarkeit
FROM ubuntu

# Zu fr√ºh -> zerst√∂rt Caching
COPY . .
# - Wird einzeln gecacht, daher bei √Ñnderungen danach nicht neu ausgef√ºhrt
# - Reproduzierbarkeit unm√∂glich
RUN apt-get update
RUN apt-get install -y cabal-install zlib1g-dev

# S.o.
RUN cabal update
RUN cabal build
# Hier sollte das gebaute Binary laufen und cabal unn√∂tig sein
CMD cabal run
#+end_src

- Keine Minimalit√§t wegen unn√∂tig enthaltener Software

* Zweiter Versuch

#+begin_src dockerfile
FROM haskell@sha256:f99b7e5417f75089b53e1077a68c6333c48b82aff478a8af292a7b7f8e541832

WORKDIR /build

COPY haskell-backend.cabal ./
COPY src-exe src-exe
RUN cabal update && cabal install

# Multi-stage build
FROM ubuntu@sha256:26c68657ccce2cb0a31b330cb0be2b5e108d467f641c62e13ab40cbec258c68d

RUN apt-get update && apt-get install -y zlib1g-dev

# Benutzer und Gruppe anlegen
RUN useradd -rm -d /home/ubuntu -s /bin/bash -g root -G sudo -u 1001 prod
USER prod

COPY --from=0 /root/.cabal/bin/haskell-backend ./
CMD [ "./haskell-backend" ]
#+end_src

Wie ist es nun?

* Zweiter Versuch: Analyse

#+begin_src dockerfile
FROM haskell@sha256:f99b7e5417f75089b53e1077a68c6333c48b82aff478a8af292a7b7f8e541832
...
#+end_src

- Feste Version der ben√∂tigten Tools ‚ûú besser

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
COPY haskell-backend.cabal ./
COPY src-exe src-exe
...
#+end_src

- Nur das N√∂tigste (vermutlich!) ‚ûú besser

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
RUN cabal update && cabal install
...
#+end_src

- Verlassen uns auf Abh√§ngigkeitsmanagement bzw. Pinning durch =cabal=

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
FROM ubuntu@sha256:26c68657ccce2cb0a31b330cb0be2b5e108d467f641c62e13ab40cbec258c68d
...
#+end_src

- Feste Basis ‚ûú besser
- Minimalit√§t?

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
RUN apt-get update && apt-get install -y zlib1g-dev
...
#+end_src

Ben√∂tigte Laufzeitabh√§ngigkeiten üòû

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
RUN useradd -rm -d /home/ubuntu -s /bin/bash -g root -G sudo -u 1001 prod
USER prod
...
#+end_src

- Service l√§uft unter dediziertem User, nicht =root= ‚ûú besser

* Zweiter Versuch: Analyse

#+begin_src dockerfile
...
COPY --from=0 /root/.cabal/bin/haskell-backend ./
CMD [ "./haskell-backend" ]
...
#+end_src

- Lediglich fertiges Binary enthalten aus vorigem Build

* Zweiter Versuch: Fazit

- Probleme beim Erstellen des =Dockerfile=: Laufzeitabh√§ngigkeiten
  fehlen oder unpassend!
- =alpine= nicht einfach m√∂glich (=musl= vs. =libc=, andere
  Bibliotheken/Versionen)
- Anzahl Pinning-Mechanismen = Anzahl Tools, Sprachen etc.

* Zweiter Versuch: Fazit

- Probleme beim Erstellen des =Dockerfile=: Laufzeitabh√§ngigkeiten
  fehlen oder unpassend! *(Reproduzierbarkeit)*
- =alpine= nicht einfach m√∂glich (=musl= vs. =libc=, andere
  Bibliotheken/Versionen) *(Minimalit√§t)*
- Anzahl Pinning-Mechanismen = Anzahl Tools, Sprachen
  etc. (*Reproduzierbarkeit*)

FIXME Notes: Tools hei√üt nicht unbedingt "Zur Entwicklung". Sobald
Docker verwendet wird, braucht man neue Tools. "Accelerate" -> freie
Toolwahl macht produktiver

‚ûú Gute Dockerfiles existieren, aber sie sind sehr schwer zu schreiben

‚ûú Je "besser" das Dockerfile, desto h√∂her der Wartungsaufwand

* Wunsch

- Abh√§ngigkeitsgraph(en) unserer Programme bekannt und fixiert

* Bauen?

FIXME

* Laufen lassen?

#+begin_src console
$ ldd ~/path/to/haskell-backend
linux-vdso.so.1 (0x00007ffebdb24000)
libpthread.so.0 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/libpthread.so.0 (0x00007fb3b72db000)
libz.so.1 => /nix/store/b36ilvc5hhfpcp7kv1kvrkgcxxpmxfsd-zlib-1.2.12/lib/libz.so.1 (0x00007fb3b72bd000)
libgmp.so.10 => /nix/store/qxrvrhlfaislinykki6qy6nqd4wv8mdp-gmp-with-cxx-6.2.1/lib/libgmp.so.10 (0x00007fb3b721c000)
libc.so.6 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/libc.so.6 (0x00007fb3b701d000)
libm.so.6 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/libm.so.6 (0x00007fb3b6f42000)
librt.so.1 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/librt.so.1 (0x00007fb3b6f3d000)
libdl.so.2 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/libdl.so.2 (0x00007fb3b6f38000)
libffi.so.8 => /nix/store/gm6q7jmajjmnwd29wgbq2jm3x37vsw3h-libffi-3.4.2/lib/libffi.so.8 (0x00007fb3b6f2b000)
/nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib/ld-linux-x86-64.so.2 => /nix/store/ayrsyv7npr0lcbann4k9lxr19x813f0z-glibc-2.34-115/lib64/ld-linux-x86-64.so.2 (0x00007fb3b72e2000)
#+end_src

* Nix!

https://nixos.org

- Programmiersprache
- Package-Manager f√ºr "Bauanleitungen" (sprachagnostisch)
- (Betriebssystem)

TODO NIXKRAM, Bauanleitung zeigen, evtl. Diagramm mit Phasen, auch
Patch zeigen!

* =haskell_backend/default.nix=

#+begin_src nix
{ pkgs ? import <nixpkgs> { } }:

pkgs.haskellPackages.callCabal2nix "haskell-backend" ./. { }
#+end_src

* =go_backend/default.nix=

#+begin_src nix
{ pkgs ? import <nixpkgs> { } }:

pkgs.buildGoModule {
  src = pkgs.lib.cleanSource ./.;
  pname = "go_backend";
  version = "0.1.0";
  vendorSha256 = "sha256-pQpattmS9VmO3ZIQUFn66az8GSmB4IvYhTTCFn6SUmo=";
}
#+end_src

* =python_client/default.nix=

#+begin_src nix
{ pkgs ? import <nixpkgs> { } }:

let myPython = pkgs.python310.withPackages (p: [ p.loguru p.requests ]);
in pkgs.writeShellScript "demo" ''
  ${myPython}/bin/python ${./python_client}/__init__.py
''
#+end_src

* Docker-Images mit Nix bauen

- Docker-Layers bestehen aus File-System-Diffs (OCI Image Format)
- Kennen Abschluss nixifizierter Anwendungen

‚ûú Kennen auch das Diff

* Neue Anforderung

Beide Services in einem Image!

FIXME =ldd=-Beispiel

FIXME ...

* Nix-H√ºrden

- Lernkurve
- Obskure Sprache
- Dokumentation
- Bewegt sich sehr schnell
- Gro√üe Unterschiede bei Sprachunterst√ºtzung
